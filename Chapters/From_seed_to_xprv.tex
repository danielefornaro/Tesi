% Chapter 1

\chapter{Hierarchical Deterministic Wallet} % Main chapter title

\label{hd wallet} % For referencing the chapter elsewhere, use \ref{Chapter1}

%----------------------------------------------------------------------------------------

% Define some commands to keep the formatting separated from the content 
%\newcommand{\keyword}[1]{\textbf{#1}}
%\newcommand{\tabhead}[1]{\textbf{#1}}
%\newcommand{\code}[1]{\texttt{#1}}
%\newcommand{\file}[1]{\texttt{\bfseries#1}}
%\newcommand{\option}[1]{\texttt{\itshape#1}}

%----------------------------------------------------------------------------------------

In this chapter we will see how an HD wallet works.
\\ \\
\section{Elements}
Let's focus on the main elements of the Wallet:
\begin{itemize}[label=$\diamond$]
	\item Seed
	\item Extended keys
\end{itemize}

\subsection{Seed}
The entire Wallet is based on a \textit{seed}.
\\ \\
It is a number taken from a \textit{Discrete Uniform Random Variable}
\begin{equation*}
seed=X(\omega) \qquad X\sim \mathcal{U}(S)
\end{equation*}
Where $S$ is the finite set of natural number in the range from $1$ to an arbitrary value.\\ Obviously the greater the set from which the number can be extracted, the better it is for the security of the seed itself.
\\ \\
This is an example of seed expressed in hexadecimal format: \\
\textit{seed}=fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999 \\ 693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542 

\subsection{Extended Key}
An Extended Key is a sequence of bytes, encoded in base58. It contains all the information necessary for the derivation. When the derivation is made for the first time from the seed, the extended key is called master key.\\ \\
Once it is decoded we will obtain exactly 78 bytes, with a specific meaning and order:
\begin{itemize}[label=$\circledast$]
	\item 4 bytes are used to specified the \textbf{version}.
	\item 1 byte is used to specified the \textbf{depth} in the hierarchical tree: the extended key derived directly from the seed has $depth=0$, its first children have $depth=1$, grandchildren have $depth=2$ and so on.
	\item 4 bytes are used for the \textbf{fingerprint}. It is a unique value that identify the parent. Compute the HASH160 function on the "parent" public key in a compressed form and then take the first 4 bytes, this is the fingerprint of the child:
	\begin{equation*}
	fingerprint=HASH160(\text{parent public key})[0:4]
	\end{equation*}
	Where $[0:4]$ is a python notation.\\
	For the master key the fingerprint is formed by 4 zeros bytes: $fingerprint=0000000000$
	\item 4 bytes are used to specified the \textbf{index} of the child. \\
	For the master key the index is formed by 4 zeros bytes: $index=0000000000$
	\item 32 bytes are used for the \textbf{chain code}. The chain code is used in order to introduce a sort of entropy in the children generation. We will see below how it works.
	\item 33 bytes are used for the \textbf{key}. It can be \textit{private} or \textit{public}. \\ Public key is expressed in compact form, so the first byte is always $02$ or $03$. The first byte of the private key is always $00$ in order to distinguish the key from the public one.\\
\end{itemize}
An extended key is called \textbf{Extended Private Key} if the lasts 33 bytes are used to specify the private key; it is called \textbf{Extended Public Key} if they are used to specify the public key.
\\ \\
For the Bitcoin mainnet it is used for the \textbf{version}: $0x0488ADE4$ for an extended private key, $0x0488B21E$ for an extended public key. When this bytes are encoded in base58, they returns \textit{xprv} and \textit{xpub} respectively.
 
\section{From SEED to Master Private Key}
In this section we will see in detail how it is possible to switch from a \textit{seed} to a \textit{master private key}. \\ \\
First of all we need to convert the seed into a string of bytes, where the most significant bytes come first (big endian). In order to do so, we need to know how much long we want the string of bytes. \\ \\
Let's see a practical example:
\begin{equation*}
\begin{split}
&byte\_string_1=00\; 00\; 00 \; 01 \\
&byte\_string_2=00\; 00\; 01 \\
&byte\_string_3=00\; 01 \\
&byte\_string_4=01
\end{split}
\end{equation*}
These $4$ byte strings are obtained from the same seed: $seed=1$ and the only different is the length of the string.
\begin{remark}
	Different length of string produce different master private key, even if the seed is the same number.
\end{remark}
In python:
\begin{lstlisting}[language=Python]
byte_string = seed.to_bytes(seed_bytes, 'big')
\end{lstlisting}
Where $seed$ is a \textit{int}, \textit{seed\_bytes} is the number of bytes that the \textit{byte\_string} should have. \\ \\
It is essential to specify the length of the byte string, otherwise there will be obtained different wallets. \\ \\
Once we obtain a string of bytes, we will compute the HMAC algorithm. The hash function used for HMAC is the SHA512 and the \textit{key} is a particular string of bytes: \textit{b"Bitcoin seed"}. In python the implementation is the follow:

\begin{lstlisting}[language=Python]
from hashlib import sha512
from hmac import HMAC

hashValue = HMAC(b"Bitcoin seed", byte_string, sha512).digest()
\end{lstlisting}
Where \textit{.digest()} is used in order to return a string of bytes.
\\ \\
Now we have obtained an \textit{hashValue} of $512$ bits, so $64$ bytes. Consider the firsts $32$ bytes as the master private key and the next $32$ bytes as the master chain code. A python implementation is the follow:

\begin{lstlisting}[language=Python]
private_key_bytes = hashValue[0:32]
chain_code_bytes = hashValue[32:64]
\end{lstlisting}
\begin{flushleft}
	Now we have two byte strings, one for the master private key and the other for the master chain code.
\end{flushleft}
It is important to remember that a private key must be in the range between $1$ and $order$, so the byte string for the private key should be converted in \textit{int} and then take the \textit{mod order}. In python we have:

\begin{lstlisting}[language=Python]
private_key = int(private_key_bytes.hex(), 16) % order
\end{lstlisting}
\begin{flushleft}
	Finally we will concatenate all the informations obtained in order to form a Master Extended Private Key (in bytes format):
\end{flushleft}

\begin{itemize}
	\item vbytes = $b'\backslash x04\backslash x88\backslash xAD\backslash xE4'$
	\item depth = $b'\backslash x00'$
	\item fingerprint = $b'\backslash x00\backslash x00\backslash x00\backslash x00'$
	\item index = $b'\backslash x00\backslash x00\backslash x00\backslash x00'$
	\item chain code is the one previously computed
	\item private key = $b'\backslash x00'$ $+$ private key in bytes format, previously computed.
\end{itemize}
Then the Master Extended Private Key is formed by concatenation:

\begin{lstlisting}[language=Python]
xkey = vbytes + depth + fingerprint + index + chain_code + key
\end{lstlisting}
\begin{flushleft}
	In order to make it readable, a base58 encode is performed.
\end{flushleft}
This is an example of Master Extended Private Key: \\
xprv9s21ZrQH143K3wEaiSJZ8jYCuZF1oJoXHiwFcx2WwXqQHD4ZLdyEAFZ22M4 BmQT82HRbWssLArj53YDQTj6vSN4iH6nTiSQ61C5CckxUtDq

\begin{remark}
	The SHA512 is an irreversible function, so it is infeasible to obtained the seed, knowing the Extended Key. (It is also useless because with the master key you can derive all the keys in the wallet).
\end{remark}

\section{Child Key derivation}
From any extended private key it is possible to obtain different child keys. There are two method used in order to do so:
\begin{itemize}
	\item Normal
	\item Hardened
\end{itemize}
Both methods have some advantage and disadvantage that we will discuss later. For every situation it is essential to use the method that best fit.
\\ \\
For both the method the derivation starts from a Extended Private Key. From this key some essential information are necessary:
\begin{itemize}[label=$\star$]
	\item Chain code
	\item Private key
\end{itemize}
It is also required a number, used in order to specify the \textbf{index} of the child. This number should be in the range between $0$ and $4294967295$. This is due to the fact that in any Extended Key there are 4 bytes used to specify the index of the child:
\begin{equation*}
	max \; index=(FF\;FF\;FF\;FF)_{16} = (4294967295)_{10}
\end{equation*}
In fact it is possible to generate even a greater number of children from the same parent, but it would not be possible to write the corresponding Extended Key in the format described above.

\section{Normal derivation}

As already mentioned we need only 3 ingredient in order to derive a key. Let's see how we can combine them together in order to obtain a new key (and chain code). \\ \\
First we need to compute the Parent Public Key $P$. This is obtained from the usual scalar multiplication of an EC point (the Generator $G$) with the Parent Private Key $p$:

\begin{equation*}
P=p\cdot G
\end{equation*}
Consider only the compress form of $P$ and convert this value into a byte string, obtaining 33 bytes.
\\ \\
Concatenate this number 33 byte string to the 4 byte string representing the index number:

\begin{equation*}
msg = compressed \; public\;key \;|\; index
\end{equation*}
$msg$ is a string of $37$ bytes. \\ \\
Apply the HMAC algorithm with the following input:

\begin{itemize}[label=$\odot$]
	\item \textbf{Hash function}: SHA512
	\item \textbf{Key}: chain code
	\item \textbf{Message}: $msg$
\end{itemize}
The Python code is the follow:
\begin{lstlisting}[language=Python]
from hmac import HMAC
from hashlib import sha512

msg=parent_key + index
hashValue = HMAC(parent_chain_code, msg, sha512).digest()
\end{lstlisting}
\begin{flushleft}
	The result is a string of 64 bytes: \textit{hashValue}.
\end{flushleft}
Split this string of bytes in two: the last 32 are the child chain code. Take the first 32 bytes, convert them into an integer number and sum it to the parent private key (mod \textit{order}), obtaining the child private key.\\ \\
This is the python code:

\begin{lstlisting}[language=Python]
child_chain_code = hashValue[32:]
p = int(hashValue[:32].hex(), 16)
child_private_key = (p + parent_private_key) % order
\end{lstlisting}